"use client"

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three"
import React, { MutableRefObject, useEffect, useRef, useState } from "react"
import { useGLTF, useAnimations, PerspectiveCamera } from "@react-three/drei"
import { GroupProps, useFrame } from "@react-three/fiber"
import { useTheme } from "next-themes"
import { themeModeAndColor, themeColors, Theme } from "@/lib/themes"

const color = new THREE.Color()

export const Model = ({ scroll, ...props }: {scroll: MutableRefObject<number>}) => {
  const group = useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF("/model.glb");
  const { actions } = useAnimations(animations, group);
  const [hovered, set] = useState<string|null>(null);
  const [materialColor, setMaterialColor] = useState<string>("#F20D2F");
  const { theme } = useTheme()

  useEffect(() => {
    const { color } = themeModeAndColor(theme as Theme);
    const colorProps = themeColors.find((c) => c.name === color);
    if (colorProps) {
      setMaterialColor(colorProps.colors.default);
    }
  }, [theme])
  
  const extras = { receiveShadow: true, castShadow: true, "material-envMapIntensity": 0.2 }
  
  useEffect(() => void (actions["CameraAction.005"]!.play().paused = true), [])
  
  useEffect(() => {
    // @ts-ignore
    if (hovered) group.current?.getObjectByName(hovered)?.material.color.set("white")
    document.body.style.cursor = hovered ? "pointer" : "auto"
  }, [hovered])

  useFrame((state) => {
    actions["CameraAction.005"]!.time = THREE.MathUtils.lerp(actions["CameraAction.005"]!.time, actions["CameraAction.005"]!.getClip().duration * scroll.current, 0.05)
    group.current?.children[0].children.forEach((child, index) => {
      // @ts-ignore
      child.material.color.lerp(color.set(hovered === child.name ? materialColor : "#202020"), hovered ? 0.1 : 0.05)
      const et = state.clock.elapsedTime
      child.position.y = Math.sin((et + index * 2000) / 2) * 1
      child.rotation.x = Math.sin((et + index * 2000) / 3) / 10
      child.rotation.y = Math.cos((et + index * 2000) / 2) / 10
      child.rotation.z = Math.sin((et + index * 2000) / 3) / 10
    })
  })

  return (
    <group ref={group} {...props} dispose={null}>
      <group
        onPointerOver={(e) => (e.stopPropagation(), set(e.object.name))}
        onPointerOut={(e) => (e.stopPropagation(), set(null))}
        position={[0.06, 4.04, 0.35]}
        scale={[0.25, 0.25, 0.25]}>
        {/* @ts-ignore */}
        <mesh name="Headphones" geometry={nodes.Headphones.geometry} material={materials.M_Headphone} {...extras} />
        {/* @ts-ignore */}
        <mesh name="Notebook" geometry={nodes.Notebook.geometry} material={materials.M_Notebook} {...extras} />
        {/* @ts-ignore */}
        <mesh name="Rocket003" geometry={nodes.Rocket003.geometry} material={materials.M_Rocket} {...extras} />
        {/* @ts-ignore */}
        <mesh name="Roundcube001" geometry={nodes.Roundcube001.geometry} material={materials.M_Roundcube} {...extras} />
        {/* @ts-ignore */}
        <mesh name="Table" geometry={nodes.Table.geometry} material={materials.M_Table} {...extras} />
        {/* @ts-ignore */}
        <mesh name="VR_Headset" geometry={nodes.VR_Headset.geometry} material={materials.M_Headset} {...extras} />
        {/* @ts-ignore */}
        <mesh name="Zeppelin" geometry={nodes.Zeppelin.geometry} material={materials.M_Zeppelin} v />
      </group>
      <group name="Camera" position={[-1.78, 2.04, 23.58]} rotation={[1.62, 0.01, 0.11]}>
        <PerspectiveCamera makeDefault far={100} near={0.1} fov={28} rotation={[-Math.PI / 2, 0, 0]}>
          <directionalLight
            castShadow
            position={[10, 20, 15]}
            shadow-camera-right={8}
            shadow-camera-top={8}
            shadow-camera-left={-8}
            shadow-camera-bottom={-8}
            shadow-mapSize-width={1024}
            shadow-mapSize-height={1024}
            intensity={2}
            shadow-bias={-0.0001}
          />
        </PerspectiveCamera>
      </group>
    </group>
  )
}

useGLTF.preload("/model.glb")
